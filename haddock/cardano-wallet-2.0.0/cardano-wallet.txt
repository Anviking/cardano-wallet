-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | The Wallet Backend for a Cardano node.
--   
--   Please see README.md
@package cardano-wallet
@version 2.0.0


-- | Decoder for the rust-cardano packfile format.
--   
--   A pack file is a collection of bytestring blobs.
--   
--   The reference implementation is in <a>packfile.rs</a>.
module Cardano.Wallet.Binary.Packfile

-- | Decode a Cardano version 1 pack file. The blobs are returned as a
--   list. Decoding is not incremental, and all data is stored in memory.
decodePackfile :: ByteString -> Either PackfileError [ByteString]

-- | Things related to the file format that can go wrong when decoding a
--   pack file.
data PackfileError
MissingMagicError :: PackfileError
WrongFileTypeError :: PackfileError
VersionTooOldError :: PackfileError
VersionTooNewError :: PackfileError
BlobDecodeError :: String -> PackfileError
instance GHC.Classes.Eq Cardano.Wallet.Binary.Packfile.PackfileError
instance GHC.Show.Show Cardano.Wallet.Binary.Packfile.PackfileError

module Cardano.Wallet.Slotting

-- | A slot identifier is the combination of an epoch and slot.
data SlotId
SlotId :: !EpochIndex -> !LocalSlotIndex -> SlotId
[epochIndex] :: SlotId -> !EpochIndex
[slotNumber] :: SlotId -> !LocalSlotIndex

-- | Denotes a chain epoch, which contains a certain number of slots.
newtype EpochIndex
EpochIndex :: Word64 -> EpochIndex
[getEpochIndex] :: EpochIndex -> Word64

-- | Denotes the slot number within an epoch.
newtype LocalSlotIndex
LocalSlotIndex :: Word16 -> LocalSlotIndex
[getLocalSlotIndex] :: LocalSlotIndex -> Word16
type SlotCount = Natural

-- | Hard-coded for the time being
slotsPerEpoch :: SlotCount

-- | Add a number of slots to an (Epoch, LocalSlotIndex) pair, where the
--   number of slots can be greater than one epoch.
addSlots :: SlotCount -> SlotId -> SlotId

-- | <tt>slotDiff a b</tt> is the number of slots by which <tt>a</tt> is
--   greater than <tt>b</tt>.
slotDiff :: SlotId -> SlotId -> Integer

-- | The slot after.
slotNext :: SlotId -> SlotId

-- | The slot before, if there is one.
slotPrev :: SlotId -> Maybe SlotId

-- | Whether the epoch index and slot number are in range.
isValidSlotId :: SlotId -> Bool
instance GHC.Generics.Generic Cardano.Wallet.Slotting.SlotId
instance GHC.Classes.Ord Cardano.Wallet.Slotting.SlotId
instance GHC.Classes.Eq Cardano.Wallet.Slotting.SlotId
instance GHC.Show.Show Cardano.Wallet.Slotting.SlotId
instance Control.DeepSeq.NFData Cardano.Wallet.Slotting.LocalSlotIndex
instance GHC.Enum.Enum Cardano.Wallet.Slotting.LocalSlotIndex
instance GHC.Num.Num Cardano.Wallet.Slotting.LocalSlotIndex
instance GHC.Generics.Generic Cardano.Wallet.Slotting.LocalSlotIndex
instance GHC.Classes.Ord Cardano.Wallet.Slotting.LocalSlotIndex
instance GHC.Classes.Eq Cardano.Wallet.Slotting.LocalSlotIndex
instance GHC.Show.Show Cardano.Wallet.Slotting.LocalSlotIndex
instance Control.DeepSeq.NFData Cardano.Wallet.Slotting.EpochIndex
instance GHC.Enum.Enum Cardano.Wallet.Slotting.EpochIndex
instance GHC.Num.Num Cardano.Wallet.Slotting.EpochIndex
instance GHC.Generics.Generic Cardano.Wallet.Slotting.EpochIndex
instance GHC.Classes.Ord Cardano.Wallet.Slotting.EpochIndex
instance GHC.Classes.Eq Cardano.Wallet.Slotting.EpochIndex
instance GHC.Show.Show Cardano.Wallet.Slotting.EpochIndex
instance GHC.Enum.Bounded Cardano.Wallet.Slotting.LocalSlotIndex


-- | This module contains the core primitive of a Wallet. This is roughly a
--   Haskell translation of the <a>Formal Specification for a Cardano
--   Wallet</a>
--   
--   It doesn't contain any particular business-logic code, but define a
--   few primitive operations on Wallet core types as well.
module Cardano.Wallet.Primitive
data Block
Block :: !BlockHeader -> !Set Tx -> Block
[header] :: Block -> !BlockHeader
[transactions] :: Block -> !Set Tx
data BlockHeader
BlockHeader :: !EpochIndex -> !LocalSlotIndex -> !Hash "BlockHeader" -> BlockHeader
[epochIndex] :: BlockHeader -> !EpochIndex
[slotNumber] :: BlockHeader -> !LocalSlotIndex
[prevBlockHash] :: BlockHeader -> !Hash "BlockHeader"
data Tx
Tx :: ![TxIn] -> ![TxOut] -> Tx

-- | Order of inputs matters in the transaction representation. The
--   transaction id is computed from the binary representation of a tx, for
--   which inputs are serialized in a specific order.
[inputs] :: Tx -> ![TxIn]

-- | Order of outputs matter in the transaction representations. Outputs
--   are used as inputs for next transactions which refer to them using
--   their indexes. It matters also for serialization.
[outputs] :: Tx -> ![TxOut]
data TxIn
TxIn :: !Hash "Tx" -> !Word32 -> TxIn
[inputId] :: TxIn -> !Hash "Tx"
[inputIx] :: TxIn -> !Word32
data TxOut
TxOut :: !Address -> !Coin -> TxOut
[address] :: TxOut -> !Address
[coin] :: TxOut -> !Coin
txIns :: Set Tx -> Set TxIn
updatePending :: Block -> Set Tx -> Set Tx
newtype Address
Address :: ByteString -> Address
[getAddress] :: Address -> ByteString

-- | This abstraction exists to give us the ability to keep the wallet
--   business logic agnostic to the address derivation and discovery
--   mechanisms.
--   
--   This is needed because two different address schemes lives on Cardano:
--   - A hierarchical random scheme: rather <tt>custom</tt> made, with
--   several flaws; this is the original and now legacy address scheme.
--   
--   <ul>
--   <li>A hierarchical sequential scheme: a new scheme based on the
--   BIP-0044 specification, which is better suited for our present
--   needs.</li>
--   </ul>
--   
--   In practice, we will need a wallet that can support both, even if not
--   at the same time, and this little abstraction can buy us this without
--   introducing too much overhead.
class IsOurs s
isOurs :: IsOurs s => Address -> s -> (Bool, s)

-- | Coins are stored as Lovelace (reminder: 1 Lovelace = 1e6 ADA)
newtype Coin
Coin :: Word64 -> Coin
[getCoin] :: Coin -> Word64
isValidCoin :: Coin -> Bool
newtype UTxO
UTxO :: Map TxIn TxOut -> UTxO
[getUTxO] :: UTxO -> Map TxIn TxOut
balance :: UTxO -> Integer
excluding :: UTxO -> Set TxIn -> UTxO
isSubsetOf :: UTxO -> UTxO -> Bool
restrictedBy :: UTxO -> Set TxIn -> UTxO
restrictedTo :: UTxO -> Set TxOut -> UTxO
class Dom a where {
    type family DomElem a :: *;
}
dom :: Dom a => a -> Set (DomElem a)
newtype Hash (tag :: Symbol)
Hash :: ByteString -> Hash
[getHash] :: Hash -> ByteString

-- | A polymorphic wrapper type with a custom show instance to display data
--   through <a>Buildable</a> instances.
newtype ShowFmt a
ShowFmt :: a -> ShowFmt a
instance GHC.Classes.Ord a => GHC.Classes.Ord (Cardano.Wallet.Primitive.ShowFmt a)
instance GHC.Classes.Eq a => GHC.Classes.Eq (Cardano.Wallet.Primitive.ShowFmt a)
instance GHC.Generics.Generic (Cardano.Wallet.Primitive.ShowFmt a)
instance GHC.Generics.Generic Cardano.Wallet.Primitive.Block
instance GHC.Classes.Ord Cardano.Wallet.Primitive.Block
instance GHC.Classes.Eq Cardano.Wallet.Primitive.Block
instance GHC.Show.Show Cardano.Wallet.Primitive.Block
instance GHC.Generics.Generic Cardano.Wallet.Primitive.BlockHeader
instance GHC.Classes.Ord Cardano.Wallet.Primitive.BlockHeader
instance GHC.Classes.Eq Cardano.Wallet.Primitive.BlockHeader
instance GHC.Show.Show Cardano.Wallet.Primitive.BlockHeader
instance GHC.Classes.Eq Cardano.Wallet.Primitive.Tx
instance GHC.Classes.Ord Cardano.Wallet.Primitive.Tx
instance GHC.Generics.Generic Cardano.Wallet.Primitive.Tx
instance GHC.Show.Show Cardano.Wallet.Primitive.Tx
instance GHC.Base.Monoid Cardano.Wallet.Primitive.UTxO
instance GHC.Base.Semigroup Cardano.Wallet.Primitive.UTxO
instance GHC.Classes.Ord Cardano.Wallet.Primitive.UTxO
instance GHC.Classes.Eq Cardano.Wallet.Primitive.UTxO
instance GHC.Generics.Generic Cardano.Wallet.Primitive.UTxO
instance GHC.Show.Show Cardano.Wallet.Primitive.UTxO
instance GHC.Classes.Ord Cardano.Wallet.Primitive.TxIn
instance GHC.Classes.Eq Cardano.Wallet.Primitive.TxIn
instance GHC.Generics.Generic Cardano.Wallet.Primitive.TxIn
instance GHC.Show.Show Cardano.Wallet.Primitive.TxIn
instance GHC.Classes.Ord (Cardano.Wallet.Primitive.Hash tag)
instance GHC.Classes.Eq (Cardano.Wallet.Primitive.Hash tag)
instance GHC.Generics.Generic (Cardano.Wallet.Primitive.Hash tag)
instance GHC.Show.Show (Cardano.Wallet.Primitive.Hash tag)
instance GHC.Classes.Ord Cardano.Wallet.Primitive.TxOut
instance GHC.Classes.Eq Cardano.Wallet.Primitive.TxOut
instance GHC.Generics.Generic Cardano.Wallet.Primitive.TxOut
instance GHC.Show.Show Cardano.Wallet.Primitive.TxOut
instance GHC.Generics.Generic Cardano.Wallet.Primitive.Coin
instance GHC.Classes.Eq Cardano.Wallet.Primitive.Coin
instance GHC.Classes.Ord Cardano.Wallet.Primitive.Coin
instance GHC.Show.Show Cardano.Wallet.Primitive.Coin
instance GHC.Classes.Ord Cardano.Wallet.Primitive.Address
instance GHC.Classes.Eq Cardano.Wallet.Primitive.Address
instance GHC.Generics.Generic Cardano.Wallet.Primitive.Address
instance GHC.Show.Show Cardano.Wallet.Primitive.Address
instance Formatting.Buildable.Buildable a => GHC.Show.Show (Cardano.Wallet.Primitive.ShowFmt a)
instance Control.DeepSeq.NFData Cardano.Wallet.Primitive.Block
instance Control.DeepSeq.NFData Cardano.Wallet.Primitive.BlockHeader
instance Control.DeepSeq.NFData Cardano.Wallet.Primitive.Tx
instance Control.DeepSeq.NFData Cardano.Wallet.Primitive.UTxO
instance Cardano.Wallet.Primitive.Dom Cardano.Wallet.Primitive.UTxO
instance Formatting.Buildable.Buildable Cardano.Wallet.Primitive.UTxO
instance Control.DeepSeq.NFData Cardano.Wallet.Primitive.TxIn
instance Formatting.Buildable.Buildable Cardano.Wallet.Primitive.TxIn
instance Formatting.Buildable.Buildable (Cardano.Wallet.Primitive.TxIn, Cardano.Wallet.Primitive.TxOut)
instance Control.DeepSeq.NFData (Cardano.Wallet.Primitive.Hash tag)
instance Control.DeepSeq.NFData Cardano.Wallet.Primitive.TxOut
instance Formatting.Buildable.Buildable Cardano.Wallet.Primitive.TxOut
instance Control.DeepSeq.NFData Cardano.Wallet.Primitive.Coin
instance GHC.Enum.Bounded Cardano.Wallet.Primitive.Coin
instance Formatting.Buildable.Buildable Cardano.Wallet.Primitive.Coin
instance Control.DeepSeq.NFData Cardano.Wallet.Primitive.Address
instance Formatting.Buildable.Buildable Cardano.Wallet.Primitive.Address


-- | This module contains the ticking function that is responsible for
--   invoking block acquisition functionality and executing it in periodic
--   fashion.
--   
--   Known limitations: the ticking function makes sure action is not
--   executed on already consumed block, but does not check and handle
--   block gaps (aka catching up).
module Cardano.Wallet.BlockSyncer
newtype BlockHeadersConsumed
BlockHeadersConsumed :: [BlockHeader] -> BlockHeadersConsumed
tickingFunction :: IO [Block] -> (Block -> IO ()) -> Millisecond -> BlockHeadersConsumed -> IO ()
instance GHC.Classes.Eq Cardano.Wallet.BlockSyncer.BlockHeadersConsumed
instance GHC.Show.Show Cardano.Wallet.BlockSyncer.BlockHeadersConsumed


-- | These are (partial) CBOR decoders for blocks and block headers. Note
--   that we ignore most of the block's and header's content and only
--   retrieve the pieces of information relevant to us, wallet (we do
--   assume a trusted node and therefore, we needn't to care about
--   verifying signatures and blocks themselves).
--   
--   The format described in the decoders below are the one used in the
--   Byron era of Cardano and will endure in the first stages of Shelley.
--   They are also used by components like the Rust
--   <a>cardano-http-bridge</a>.
module Cardano.Wallet.Binary
decodeBlock :: Decoder s Block
decodeBlockHeader :: Decoder s BlockHeader
decodeTx :: Decoder s Tx
encodeTx :: Tx -> Encoding

-- | Compute a transaction id; assumed to be effectively injective. It
--   returns an hex-encoded 64-byte hash.
--   
--   NOTE: This is a rather expensive operation
txId :: Tx -> Hash "Tx"

-- | Inspect the next token that has to be decoded and print it to the
--   console as a trace. Useful for debugging Decoders. Example:
--   
--   <pre>
--   myDecoder :: CBOR.Decoder s MyType
--   myDecoder = do
--       a &lt;- CBOR.decodeWord64
--       inspectNextToken
--       [...]
--   </pre>
inspectNextToken :: Decoder s ()

-- | Decode an list of known length. Very similar to
--   <tt>decodeListIndef</tt>.
--   
--   <pre>
--   myDecoder :: CBOR.Decoder s [MyType]
--   myDecoder = decodeList decodeOne
--     where
--       decodeOne :: CBOR.Decoder s MyType
--   </pre>
decodeList :: forall s a. Decoder s a -> Decoder s [a]

-- | Decode an arbitrary long list. CBOR introduce a "break" character to
--   mark the end of the list, so we simply decode each item until we
--   encounter a break character.
--   
--   <pre>
--   myDecoder :: CBOR.Decoder s [MyType]
--   myDecoder = decodeListIndef decodeOne
--     where
--       decodeOne :: CBOR.Decoder s MyType
--   </pre>
decodeListIndef :: forall s a. Decoder s a -> Decoder s [a]


-- | Here we find the "business logic" to manage a Cardano wallet. This is
--   a direct implementation of the model from the <a>Formal Specification
--   for a Cardano Wallet</a> Note that, this module is purposedly agnostic
--   to how blocks are retrieved or how various types are serialized.
--   
--   This is really about how the wallet keep track of its internal state,
--   and its UTxO (where the relationship is defined via the <a>IsOurs</a>
--   abstraction to allow this core code to be used with any sort of
--   derivation scheme).
--   
--   All those functions are pure and there's no reason to shove in any
--   sort of side-effects in here :)
module Cardano.Wallet

-- | An opaque wallet type, see <tt>initWallet</tt> and <tt>applyBlock</tt>
--   to construct and update wallets.
--   
--   Internally, this keeps track or a few things including:
--   
--   <ul>
--   <li>UTxOs</li>
--   <li>Pending transaction</li>
--   <li>TODO: Transaction history</li>
--   <li>TODO: Known &amp; used addresses</li>
--   </ul>
data Wallet s

-- | Create an empty wallet from an initial state
initWallet :: (IsOurs s, Semigroup s, NFData s, Show s) => s -> Wallet s

-- | Apply Block is the only way to make the wallet evolve.
applyBlock :: Block -> NonEmpty (Wallet s) -> NonEmpty (Wallet s)

-- | Available balance = <a>balance</a> . <a>availableUTxO</a>
availableBalance :: Wallet s -> Integer

-- | Total balance = <a>balance</a> . <a>totalUTxO</a>
totalBalance :: Wallet s -> Integer

-- | Total UTxO = <a>availableUTxO</a> &lt;&gt; "pending UTxO"
totalUTxO :: Wallet s -> UTxO

-- | Available UTxO = UTxO that aren't part of pending txs
availableUTxO :: Wallet s -> UTxO

-- | Check whether an invariants holds or not.
--   
--   <pre>
--   &gt;&gt;&gt; invariant "not empty" [1,2,3] (not . null)
--   [1, 2, 3]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; invariant "not empty" [] (not . null)
--   *** Exception: not empty
--   </pre>
invariant :: String -> a -> (a -> Bool) -> a

-- | Return all transaction outputs that are ours. This plays well within a
--   <a>State</a> monad.
--   
--   <pre>
--   myFunction :: Block -&gt; State s Result
--   myFunction b = do
--      ours &lt;- state $ txOutsOurs (transaction b)
--      return $ someComputation ours
--   </pre>
txOutsOurs :: forall s. IsOurs s => Set Tx -> s -> (Set TxOut, s)

-- | Construct a UTxO corresponding to a given transaction. It is important
--   for the transaction outputs to be ordered correctly, since they become
--   available inputs for the subsequent blocks.
utxoFromTx :: Tx -> UTxO
instance GHC.Show.Show (Cardano.Wallet.Wallet s)
instance Control.DeepSeq.NFData (Cardano.Wallet.Wallet s)

module Cardano.ChainProducer.RustHttpBridge.NetworkLayer

-- | Endpoints of the cardano-http-bridge API.
data NetworkLayer m
NetworkLayer :: (Hash "BlockHeader" -> ExceptT NetworkLayerError m Block) -> (EpochIndex -> ExceptT NetworkLayerError m [Block]) -> ExceptT NetworkLayerError m (Hash "BlockHeader", BlockHeader) -> NetworkLayer m
[getBlock] :: NetworkLayer m -> Hash "BlockHeader" -> ExceptT NetworkLayerError m Block
[getEpoch] :: NetworkLayer m -> EpochIndex -> ExceptT NetworkLayerError m [Block]
[getNetworkTip] :: NetworkLayer m -> ExceptT NetworkLayerError m (Hash "BlockHeader", BlockHeader)
newtype NetworkLayerError
NetworkLayerError :: String -> NetworkLayerError
instance GHC.Classes.Eq Cardano.ChainProducer.RustHttpBridge.NetworkLayer.NetworkLayerError
instance GHC.Show.Show Cardano.ChainProducer.RustHttpBridge.NetworkLayer.NetworkLayerError
instance GHC.Exception.Type.Exception Cardano.ChainProducer.RustHttpBridge.NetworkLayer.NetworkLayerError

module Cardano.ChainProducer
class MonadChainProducer m

-- | Get some blocks from the chain producer.
--   
--   This may retrieve less than the requested number of blocks. It might
--   return no blocks at all.
nextBlocks :: MonadChainProducer m => SlotCount -> SlotId -> ExceptT ErrGetNextBlocks m [Block]

-- | The things that can go wrong when retrieving blocks.
newtype ErrGetNextBlocks
GetNextBlocksError :: String -> ErrGetNextBlocks
instance GHC.Classes.Eq Cardano.ChainProducer.ErrGetNextBlocks
instance GHC.Show.Show Cardano.ChainProducer.ErrGetNextBlocks
instance GHC.Exception.Type.Exception Cardano.ChainProducer.ErrGetNextBlocks

module Cardano.ChainProducer.RustHttpBridge
data RustBackend a
runRustBackend :: NetworkLayer IO -> RustBackend a -> IO a
instance Control.Monad.IO.Class.MonadIO Cardano.ChainProducer.RustHttpBridge.RustBackend
instance Control.Monad.Reader.Class.MonadReader (Cardano.ChainProducer.RustHttpBridge.NetworkLayer.NetworkLayer GHC.Types.IO) Cardano.ChainProducer.RustHttpBridge.RustBackend
instance GHC.Base.Functor Cardano.ChainProducer.RustHttpBridge.RustBackend
instance GHC.Base.Applicative Cardano.ChainProducer.RustHttpBridge.RustBackend
instance GHC.Base.Monad Cardano.ChainProducer.RustHttpBridge.RustBackend
instance Cardano.ChainProducer.MonadChainProducer Cardano.ChainProducer.RustHttpBridge.RustBackend


-- | Extra content types for Servant.
module Servant.Extra.ContentTypes

-- | Represents a piece of binary data for which a hash value should be
--   calculated before performing any further deserialization.
data ComputeHash algorithm a

-- | Represents a CBOR (Concise Binary Object Representation) object.
--   
--   See RFC 7049 (http:/<i>cbor.io</i>) for further details.
data CBOR

-- | The class of types that can be converted to from CBOR.
class FromCBOR a
fromCBOR :: FromCBOR a => Decoder s a

-- | Represents the result of hashing a piece of data.
newtype Hash algorithm a
Hash :: Digest algorithm -> Hash algorithm a

-- | Represents something that has been packed with the Cardano packfile
--   format.
data Packed a

-- | Represents a piece of data with an accompanying hash value.
data WithHash algorithm a
WithHash :: Digest algorithm -> a -> WithHash algorithm a
[getHash] :: WithHash algorithm a -> Digest algorithm
[getValue] :: WithHash algorithm a -> a
instance GHC.Show.Show a => GHC.Show.Show (Servant.Extra.ContentTypes.WithHash algorithm a)
instance Servant.API.ContentTypes.Accept a => Servant.API.ContentTypes.Accept (Servant.Extra.ContentTypes.Packed a)
instance Servant.API.ContentTypes.MimeUnrender a b => Servant.API.ContentTypes.MimeUnrender (Servant.Extra.ContentTypes.Packed a) [b]
instance (Servant.API.ContentTypes.MimeUnrender a b, Crypto.Hash.Types.HashAlgorithm alg) => Servant.API.ContentTypes.MimeUnrender (Servant.Extra.ContentTypes.ComputeHash alg a) (Servant.Extra.ContentTypes.WithHash alg b)
instance Web.Internal.HttpApiData.ToHttpApiData (Servant.Extra.ContentTypes.Hash algorithm a)
instance Servant.API.ContentTypes.Accept a => Servant.API.ContentTypes.Accept (Servant.Extra.ContentTypes.ComputeHash algorithm a)
instance Servant.Extra.ContentTypes.FromCBOR a => Servant.API.ContentTypes.MimeUnrender Servant.Extra.ContentTypes.CBOR a
instance Servant.API.ContentTypes.Accept Servant.Extra.ContentTypes.CBOR


-- | An API specification for the Cardano HTTP Bridge.
module Cardano.ChainProducer.RustHttpBridge.Api
type Api = GetBlockByHash :<|> GetEpochById :<|> GetTipBlockHeader
api :: Proxy Api

-- | Represents a block.
newtype Block
Block :: Block -> Block
[getBlock] :: Block -> Block

-- | Represents a block header.
newtype BlockHeader
BlockHeader :: BlockHeader -> BlockHeader
[getBlockHeader] :: BlockHeader -> BlockHeader

-- | Represents a unique epoch.
newtype EpochIndex
EpochIndex :: EpochIndex -> EpochIndex
[getEpochIndex] :: EpochIndex -> EpochIndex

-- | Represents the name of a Cardano network.
newtype NetworkName
NetworkName :: Text -> NetworkName
[getNetworkName] :: NetworkName -> Text
instance GHC.Show.Show Cardano.ChainProducer.RustHttpBridge.Api.NetworkName
instance GHC.Classes.Eq Cardano.ChainProducer.RustHttpBridge.Api.NetworkName
instance GHC.Show.Show Cardano.ChainProducer.RustHttpBridge.Api.EpochIndex
instance GHC.Classes.Eq Cardano.ChainProducer.RustHttpBridge.Api.EpochIndex
instance GHC.Classes.Eq Cardano.ChainProducer.RustHttpBridge.Api.BlockHeader
instance GHC.Classes.Eq Cardano.ChainProducer.RustHttpBridge.Api.Block
instance Web.Internal.HttpApiData.ToHttpApiData Cardano.ChainProducer.RustHttpBridge.Api.NetworkName
instance Web.Internal.HttpApiData.ToHttpApiData Cardano.ChainProducer.RustHttpBridge.Api.EpochIndex
instance Servant.Extra.ContentTypes.FromCBOR Cardano.ChainProducer.RustHttpBridge.Api.BlockHeader
instance Servant.Extra.ContentTypes.FromCBOR Cardano.ChainProducer.RustHttpBridge.Api.Block


-- | An API client for the Cardano HTTP Bridge.
module Cardano.ChainProducer.RustHttpBridge.Client
mkNetworkLayer :: Manager -> BaseUrl -> NetworkName -> NetworkLayer IO
