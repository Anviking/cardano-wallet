-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | The Wallet Backend for a Cardano node.
--   
--   Please see README.md
@package cardano-wallet
@version 2.0.0


-- | Decoder for the rust-cardano packfile format.
--   
--   A pack file is a collection of bytestring blobs.
--   
--   The reference implementation is in <a>packfile.rs</a>.
module Cardano.Wallet.Binary.Packfile

-- | Decode a Cardano version 1 pack file. The blobs are returned as a
--   list. Decoding is not incremental, and all data is stored in memory.
decodePackfile :: ByteString -> Either PackfileError [ByteString]

-- | Things related to the file format that can go wrong when decoding a
--   pack file.
data PackfileError
MissingMagicError :: PackfileError
WrongFileTypeError :: PackfileError
VersionTooOldError :: PackfileError
VersionTooNewError :: PackfileError
BlobDecodeError :: String -> PackfileError
instance GHC.Classes.Eq Cardano.Wallet.Binary.Packfile.PackfileError
instance GHC.Show.Show Cardano.Wallet.Binary.Packfile.PackfileError


-- | This module contains the core primitive of a Wallet. This is roughly a
--   Haskell translation of the <a>Formal Specification for a Cardano
--   Wallet</a>
--   
--   It doesn't contain any particular business-logic code, but define a
--   few primitive operations on Wallet core types as well.
module Cardano.Wallet.Primitive
data Block
Block :: !BlockHeader -> !Set Tx -> Block
[header] :: Block -> !BlockHeader
[transactions] :: Block -> !Set Tx
data BlockHeader
BlockHeader :: !EpochId -> !SlotId -> !Hash "BlockHeader" -> BlockHeader
[epochIndex] :: BlockHeader -> !EpochId
[slotNumber] :: BlockHeader -> !SlotId
[prevBlockHash] :: BlockHeader -> !Hash "BlockHeader"
newtype EpochId
EpochId :: Word64 -> EpochId
[getEpochId] :: EpochId -> Word64
newtype SlotId
SlotId :: Word16 -> SlotId
[getSlotId] :: SlotId -> Word16
data Tx
Tx :: ![TxIn] -> ![TxOut] -> Tx

-- | Order of inputs matters in the transaction representation. The
--   transaction id is computed from the binary representation of a tx, for
--   which inputs are serialized in a specific order.
[inputs] :: Tx -> ![TxIn]

-- | Order of outputs matter in the transaction representations. Outputs
--   are used as inputs for next transactions which refer to them using
--   their indexes. It matters also for serialization.
[outputs] :: Tx -> ![TxOut]
data TxIn
TxIn :: !Hash "Tx" -> !Word32 -> TxIn
[inputId] :: TxIn -> !Hash "Tx"
[inputIx] :: TxIn -> !Word32
data TxOut
TxOut :: !Address -> !Coin -> TxOut
[address] :: TxOut -> !Address
[coin] :: TxOut -> !Coin
txIns :: Set Tx -> Set TxIn
txOutsOurs :: forall s. IsOurs s => Set Tx -> s -> (Set TxOut, s)
updatePending :: Block -> Set Tx -> Set Tx
newtype Address
Address :: ByteString -> Address
[getAddress] :: Address -> ByteString

-- | This abstraction exists to give us the ability to keep the wallet
--   business logic agnostic to the address derivation and discovery
--   mechanisms.
--   
--   This is needed because two different address schemes lives on Cardano:
--   - A hierarchical random scheme: rather <tt>custom</tt> made, with
--   several flaws; this is the original and now legacy address scheme.
--   
--   <ul>
--   <li>A hierarchical sequential scheme: a new scheme based on the
--   BIP-0044 specification, which is better suited for our present
--   needs.</li>
--   </ul>
--   
--   In practice, we will need a wallet that can support both, even if not
--   at the same time, and this little abstraction can buy us this without
--   introducing too much overhead.
class IsOurs s
isOurs :: IsOurs s => Address -> s -> (Bool, s)

-- | Coins are stored as Lovelace (reminder: 1 Lovelace = 1e6 ADA)
newtype Coin
Coin :: Word64 -> Coin
[getCoin] :: Coin -> Word64
isValidCoin :: Coin -> Bool
newtype UTxO
UTxO :: Map TxIn TxOut -> UTxO
[getUTxO] :: UTxO -> Map TxIn TxOut
balance :: UTxO -> Integer
excluding :: UTxO -> Set TxIn -> UTxO
isSubsetOf :: UTxO -> UTxO -> Bool
restrictedBy :: UTxO -> Set TxIn -> UTxO
restrictedTo :: UTxO -> Set TxOut -> UTxO
class Dom a where {
    type family DomElem a :: *;
}
dom :: Dom a => a -> Set (DomElem a)
newtype Hash (tag :: Symbol)
Hash :: ByteString -> Hash
[getHash] :: Hash -> ByteString
instance GHC.Generics.Generic Cardano.Wallet.Primitive.Block
instance GHC.Classes.Eq Cardano.Wallet.Primitive.Block
instance GHC.Show.Show Cardano.Wallet.Primitive.Block
instance GHC.Generics.Generic Cardano.Wallet.Primitive.BlockHeader
instance GHC.Classes.Eq Cardano.Wallet.Primitive.BlockHeader
instance GHC.Show.Show Cardano.Wallet.Primitive.BlockHeader
instance GHC.Classes.Eq Cardano.Wallet.Primitive.Tx
instance GHC.Classes.Ord Cardano.Wallet.Primitive.Tx
instance GHC.Generics.Generic Cardano.Wallet.Primitive.Tx
instance GHC.Show.Show Cardano.Wallet.Primitive.Tx
instance GHC.Base.Monoid Cardano.Wallet.Primitive.UTxO
instance GHC.Base.Semigroup Cardano.Wallet.Primitive.UTxO
instance GHC.Classes.Ord Cardano.Wallet.Primitive.UTxO
instance GHC.Classes.Eq Cardano.Wallet.Primitive.UTxO
instance GHC.Generics.Generic Cardano.Wallet.Primitive.UTxO
instance GHC.Show.Show Cardano.Wallet.Primitive.UTxO
instance GHC.Classes.Ord Cardano.Wallet.Primitive.TxIn
instance GHC.Classes.Eq Cardano.Wallet.Primitive.TxIn
instance GHC.Generics.Generic Cardano.Wallet.Primitive.TxIn
instance GHC.Show.Show Cardano.Wallet.Primitive.TxIn
instance GHC.Classes.Ord (Cardano.Wallet.Primitive.Hash tag)
instance GHC.Classes.Eq (Cardano.Wallet.Primitive.Hash tag)
instance GHC.Generics.Generic (Cardano.Wallet.Primitive.Hash tag)
instance GHC.Show.Show (Cardano.Wallet.Primitive.Hash tag)
instance GHC.Classes.Ord Cardano.Wallet.Primitive.TxOut
instance GHC.Classes.Eq Cardano.Wallet.Primitive.TxOut
instance GHC.Generics.Generic Cardano.Wallet.Primitive.TxOut
instance GHC.Show.Show Cardano.Wallet.Primitive.TxOut
instance GHC.Generics.Generic Cardano.Wallet.Primitive.Coin
instance GHC.Classes.Eq Cardano.Wallet.Primitive.Coin
instance GHC.Classes.Ord Cardano.Wallet.Primitive.Coin
instance GHC.Show.Show Cardano.Wallet.Primitive.Coin
instance GHC.Classes.Ord Cardano.Wallet.Primitive.Address
instance GHC.Classes.Eq Cardano.Wallet.Primitive.Address
instance GHC.Generics.Generic Cardano.Wallet.Primitive.Address
instance GHC.Show.Show Cardano.Wallet.Primitive.Address
instance GHC.Show.Show Cardano.Wallet.Primitive.SlotId
instance GHC.Num.Num Cardano.Wallet.Primitive.SlotId
instance Control.DeepSeq.NFData Cardano.Wallet.Primitive.SlotId
instance GHC.Generics.Generic Cardano.Wallet.Primitive.SlotId
instance GHC.Classes.Eq Cardano.Wallet.Primitive.SlotId
instance GHC.Show.Show Cardano.Wallet.Primitive.EpochId
instance GHC.Num.Num Cardano.Wallet.Primitive.EpochId
instance Control.DeepSeq.NFData Cardano.Wallet.Primitive.EpochId
instance GHC.Generics.Generic Cardano.Wallet.Primitive.EpochId
instance GHC.Classes.Eq Cardano.Wallet.Primitive.EpochId
instance Control.DeepSeq.NFData Cardano.Wallet.Primitive.Block
instance Control.DeepSeq.NFData Cardano.Wallet.Primitive.BlockHeader
instance Control.DeepSeq.NFData Cardano.Wallet.Primitive.Tx
instance Control.DeepSeq.NFData Cardano.Wallet.Primitive.UTxO
instance Cardano.Wallet.Primitive.Dom Cardano.Wallet.Primitive.UTxO
instance Control.DeepSeq.NFData Cardano.Wallet.Primitive.TxIn
instance Control.DeepSeq.NFData (Cardano.Wallet.Primitive.Hash tag)
instance Control.DeepSeq.NFData Cardano.Wallet.Primitive.TxOut
instance Control.DeepSeq.NFData Cardano.Wallet.Primitive.Coin
instance GHC.Enum.Bounded Cardano.Wallet.Primitive.Coin
instance Control.DeepSeq.NFData Cardano.Wallet.Primitive.Address


-- | These are (partial) CBOR decoders for blocks and block headers. Note
--   that we ignore most of the block's and header's content and only
--   retrieve the pieces of information relevant to us, wallet (we do
--   assume a trusted node and therefore, we needn't to care about
--   verifying signatures and blocks themselves).
--   
--   The format described in the decoders below are the one used in the
--   Byron era of Cardano and will endure in the first stages of Shelley.
--   They are also used by components like the Rust
--   <a>cardano-http-bridge</a>.
module Cardano.Wallet.Binary
decodeBlock :: Decoder s Block
decodeBlockHeader :: Decoder s BlockHeader
decodeTx :: Decoder s Tx
encodeTx :: Tx -> Encoding

-- | Compute a transaction id; assumed to be effectively injective. It
--   returns an hex-encoded 64-byte hash.
--   
--   NOTE: This is a rather expensive operation
txId :: Tx -> Hash "Tx"

-- | Inspect the next token that has to be decoded and print it to the
--   console as a trace. Useful for debugging Decoders. Example:
--   
--   <pre>
--   myDecoder :: CBOR.Decoder s MyType
--   myDecoder = do
--       a &lt;- CBOR.decodeWord64
--       inspectNextToken
--       [...]
--   </pre>
inspectNextToken :: Decoder s ()

-- | Decode an list of known length. Very similar to
--   <tt>decodeListIndef</tt>.
--   
--   <pre>
--   myDecoder :: CBOR.Decoder s [MyType]
--   myDecoder = decodeList decodeOne
--     where
--       decodeOne :: CBOR.Decoder s MyType
--   </pre>
decodeList :: forall s a. Decoder s a -> Decoder s [a]

-- | Decode an arbitrary long list. CBOR introduce a "break" character to
--   mark the end of the list, so we simply decode each item until we
--   encounter a break character.
--   
--   <pre>
--   myDecoder :: CBOR.Decoder s [MyType]
--   myDecoder = decodeListIndef decodeOne
--     where
--       decodeOne :: CBOR.Decoder s MyType
--   </pre>
decodeListIndef :: forall s a. Decoder s a -> Decoder s [a]


-- | Extra content types for Servant.
module Servant.Extra.ContentTypes

-- | Represents a piece of binary data for which a hash value should be
--   calculated before performing any further deserialization.
data ComputeHash algorithm a

-- | Represents a CBOR (Concise Binary Object Representation) object.
--   
--   See RFC 7049 (http:/<i>cbor.io</i>) for further details.
data CBOR

-- | The class of types that can be converted to from CBOR.
class FromCBOR a
fromCBOR :: FromCBOR a => Decoder s a

-- | Represents the result of hashing a piece of data.
newtype Hash algorithm a
Hash :: Digest algorithm -> Hash algorithm a

-- | Represents something that has been packed with the Cardano packfile
--   format.
data Packed a

-- | Represents a piece of data with an accompanying hash value.
data WithHash algorithm a
WithHash :: Digest algorithm -> a -> WithHash algorithm a
[getHash] :: WithHash algorithm a -> Digest algorithm
[getValue] :: WithHash algorithm a -> a
instance GHC.Show.Show a => GHC.Show.Show (Servant.Extra.ContentTypes.WithHash algorithm a)
instance Servant.API.ContentTypes.Accept a => Servant.API.ContentTypes.Accept (Servant.Extra.ContentTypes.Packed a)
instance Servant.API.ContentTypes.MimeUnrender a b => Servant.API.ContentTypes.MimeUnrender (Servant.Extra.ContentTypes.Packed a) [b]
instance (Servant.API.ContentTypes.MimeUnrender a b, Crypto.Hash.Types.HashAlgorithm alg) => Servant.API.ContentTypes.MimeUnrender (Servant.Extra.ContentTypes.ComputeHash alg a) (Servant.Extra.ContentTypes.WithHash alg b)
instance Web.Internal.HttpApiData.ToHttpApiData (Servant.Extra.ContentTypes.Hash algorithm a)
instance Servant.API.ContentTypes.Accept a => Servant.API.ContentTypes.Accept (Servant.Extra.ContentTypes.ComputeHash algorithm a)
instance Servant.Extra.ContentTypes.FromCBOR a => Servant.API.ContentTypes.MimeUnrender Servant.Extra.ContentTypes.CBOR a
instance Servant.API.ContentTypes.Accept Servant.Extra.ContentTypes.CBOR


-- | An API specification for the Cardano HTTP Bridge.
module Cardano.ChainProducer.RustHttpBridge.Api
type Api = GetBlockByHash :<|> GetEpochById :<|> GetTipBlockHeader
api :: Proxy Api

-- | Represents a block.
newtype Block
Block :: Block -> Block
[getBlock] :: Block -> Block

-- | Represents a block header.
newtype BlockHeader
BlockHeader :: BlockHeader -> BlockHeader
[getBlockHeader] :: BlockHeader -> BlockHeader

-- | Represents a unique epoch.
newtype EpochId
EpochId :: EpochId -> EpochId
[getEpochId] :: EpochId -> EpochId

-- | Represents the name of a Cardano network.
newtype NetworkName
NetworkName :: Text -> NetworkName
[getNetworkName] :: NetworkName -> Text
instance GHC.Show.Show Cardano.ChainProducer.RustHttpBridge.Api.NetworkName
instance GHC.Classes.Eq Cardano.ChainProducer.RustHttpBridge.Api.NetworkName
instance GHC.Show.Show Cardano.ChainProducer.RustHttpBridge.Api.EpochId
instance GHC.Classes.Eq Cardano.ChainProducer.RustHttpBridge.Api.EpochId
instance GHC.Classes.Eq Cardano.ChainProducer.RustHttpBridge.Api.BlockHeader
instance GHC.Classes.Eq Cardano.ChainProducer.RustHttpBridge.Api.Block
instance Web.Internal.HttpApiData.ToHttpApiData Cardano.ChainProducer.RustHttpBridge.Api.NetworkName
instance Web.Internal.HttpApiData.ToHttpApiData Cardano.ChainProducer.RustHttpBridge.Api.EpochId
instance Servant.Extra.ContentTypes.FromCBOR Cardano.ChainProducer.RustHttpBridge.Api.BlockHeader
instance Servant.Extra.ContentTypes.FromCBOR Cardano.ChainProducer.RustHttpBridge.Api.Block


-- | An API client for the Cardano HTTP Bridge.
module Cardano.ChainProducer.RustHttpBridge.Client

-- | Retrieve a block identified by the unique hash of its header.
getBlockByHash :: NetworkName -> Hash Blake2b_256 BlockHeader -> ClientM Block

-- | Retrieve all the blocks for the epoch identified by the given integer
--   ID.
getEpochById :: NetworkName -> EpochId -> ClientM [Block]

-- | Retrieve the header of the latest known block.
getTipBlockHeader :: NetworkName -> ClientM (WithHash Blake2b_256 BlockHeader)
